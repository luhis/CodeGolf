/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.5.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

export interface IAccessClient {
    isLoggedIn(): Promise<boolean>;
    isAdmin(): Promise<boolean>;
    signOut(): Promise<void>;
}

export class AccessClient implements IAccessClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    isLoggedIn(): Promise<boolean> {
        let url_ = this.baseUrl + "/api/access/isloggedin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processIsLoggedIn(_response);
        });
    }

    protected processIsLoggedIn(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    isAdmin(): Promise<boolean> {
        let url_ = this.baseUrl + "/api/access/isadmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processIsAdmin(_response);
        });
    }

    protected processIsAdmin(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    signOut(): Promise<void> {
        let url_ = this.baseUrl + "/api/access/signout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSignOut(_response);
        });
    }

    protected processSignOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IAccountClient {
    signIn(returnUrl: string | null | undefined): Promise<FileResponse>;
}

export class AccountClient implements IAccountClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    signIn(returnUrl: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/account/signin?";
        if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export interface IAdminClient {
    endHole(): Promise<void>;
    nextHole(): Promise<void>;
    results(holeId: string): Promise<AttemptDto[]>;
    currentHole(): Promise<HoleDto>;
    finalScores(): Promise<ResultDto[]>;
    attempt(attemptId: string): Promise<AttemptCodeDto>;
    myGames(): Promise<GameDto[]>;
    reset(gameId: string): Promise<void>;
    allChallenges(): Promise<ChallengeOverView[]>;
}

export class AdminClient implements IAdminClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    endHole(): Promise<void> {
        let url_ = this.baseUrl + "/api/admin/endhole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processEndHole(_response);
        });
    }

    protected processEndHole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    nextHole(): Promise<void> {
        let url_ = this.baseUrl + "/api/admin/nexthole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processNextHole(_response);
        });
    }

    protected processNextHole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    results(holeId: string): Promise<AttemptDto[]> {
        let url_ = this.baseUrl + "/api/admin/results/{holeId}";
        if (holeId === undefined || holeId === null)
            throw new Error("The parameter 'holeId' must be defined.");
        url_ = url_.replace("{holeId}", encodeURIComponent("" + holeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processResults(_response);
        });
    }

    protected processResults(response: AxiosResponse): Promise<AttemptDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttemptDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttemptDto[]>(<any>null);
    }

    currentHole(): Promise<HoleDto> {
        let url_ = this.baseUrl + "/api/admin/currenthole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCurrentHole(_response);
        });
    }

    protected processCurrentHole(response: AxiosResponse): Promise<HoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HoleDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HoleDto>(<any>null);
    }

    finalScores(): Promise<ResultDto[]> {
        let url_ = this.baseUrl + "/api/admin/finalscores";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processFinalScores(_response);
        });
    }

    protected processFinalScores(response: AxiosResponse): Promise<ResultDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResultDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultDto[]>(<any>null);
    }

    attempt(attemptId: string): Promise<AttemptCodeDto> {
        let url_ = this.baseUrl + "/api/admin/attempt/{attemptId}";
        if (attemptId === undefined || attemptId === null)
            throw new Error("The parameter 'attemptId' must be defined.");
        url_ = url_.replace("{attemptId}", encodeURIComponent("" + attemptId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAttempt(_response);
        });
    }

    protected processAttempt(response: AxiosResponse): Promise<AttemptCodeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttemptCodeDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttemptCodeDto>(<any>null);
    }

    myGames(): Promise<GameDto[]> {
        let url_ = this.baseUrl + "/api/admin/mygames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processMyGames(_response);
        });
    }

    protected processMyGames(response: AxiosResponse): Promise<GameDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GameDto[]>(<any>null);
    }

    reset(gameId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/admin/reset/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processReset(_response);
        });
    }

    protected processReset(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    allChallenges(): Promise<ChallengeOverView[]> {
        let url_ = this.baseUrl + "/api/admin/allchallenges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAllChallenges(_response);
        });
    }

    protected processAllChallenges(response: AxiosResponse): Promise<ChallengeOverView[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChallengeOverView.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChallengeOverView[]>(<any>null);
    }
}

export interface IChallengeClient {
    demoChallenge(): Promise<ChallengeSetDto>;
    currentChallenge(): Promise<HoleDto>;
    submitDemo(code: string): Promise<SubmissionResult>;
    submitChallenge(holeId: string, code: string): Promise<SubmissionResult>;
}

export class ChallengeClient implements IChallengeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    demoChallenge(): Promise<ChallengeSetDto> {
        let url_ = this.baseUrl + "/api/challenge/demochallenge";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDemoChallenge(_response);
        });
    }

    protected processDemoChallenge(response: AxiosResponse): Promise<ChallengeSetDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChallengeSetDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChallengeSetDto>(<any>null);
    }

    currentChallenge(): Promise<HoleDto> {
        let url_ = this.baseUrl + "/api/challenge/currentchallenge";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCurrentChallenge(_response);
        });
    }

    protected processCurrentChallenge(response: AxiosResponse): Promise<HoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HoleDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HoleDto>(<any>null);
    }

    submitDemo(code: string): Promise<SubmissionResult> {
        let url_ = this.baseUrl + "/api/challenge/submitdemo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(code);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSubmitDemo(_response);
        });
    }

    protected processSubmitDemo(response: AxiosResponse): Promise<SubmissionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SubmissionResult.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubmissionResult>(<any>null);
    }

    submitChallenge(holeId: string, code: string): Promise<SubmissionResult> {
        let url_ = this.baseUrl + "/api/challenge/submitchallenge/{holeId}";
        if (holeId === undefined || holeId === null)
            throw new Error("The parameter 'holeId' must be defined.");
        url_ = url_.replace("{holeId}", encodeURIComponent("" + holeId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(code);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSubmitChallenge(_response);
        });
    }

    protected processSubmitChallenge(response: AxiosResponse): Promise<SubmissionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SubmissionResult.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubmissionResult>(<any>null);
    }
}

export interface ICodeClient {
    preview(code: string | null | undefined): Promise<string>;
    debug(code: string | null | undefined): Promise<string>;
    tryCompile(code: string): Promise<CompileErrorMessage[]>;
}

export class CodeClient implements ICodeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    preview(code: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/code/preview?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processPreview(_response);
        });
    }

    protected processPreview(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    debug(code: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/code/debug?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDebug(_response);
        });
    }

    protected processDebug(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    tryCompile(code: string): Promise<CompileErrorMessage[]> {
        let url_ = this.baseUrl + "/api/code/trycompile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(code);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTryCompile(_response);
        });
    }

    protected processTryCompile(response: AxiosResponse): Promise<CompileErrorMessage[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompileErrorMessage.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CompileErrorMessage[]>(<any>null);
    }
}

export class AttemptDto implements IAttemptDto {
    rank!: number;
    id!: string;
    loginName!: string | undefined;
    avatar!: string | undefined;
    score!: number;
    timeStamp!: Date;

    constructor(data?: IAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rank = _data["rank"];
            this.id = _data["id"];
            this.loginName = _data["loginName"];
            this.avatar = _data["avatar"];
            this.score = _data["score"];
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rank"] = this.rank;
        data["id"] = this.id;
        data["loginName"] = this.loginName;
        data["avatar"] = this.avatar;
        data["score"] = this.score;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAttemptDto {
    rank: number;
    id: string;
    loginName: string | undefined;
    avatar: string | undefined;
    score: number;
    timeStamp: Date;
}

export class HoleDto implements IHoleDto {
    hole!: Hole | undefined;
    start!: Date;
    end!: Date;
    closedAt!: Date | undefined;
    hasNext!: boolean;
    challengeSet!: ChallengeSetDto | undefined;

    constructor(data?: IHoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hole = _data["hole"] ? Hole.fromJS(_data["hole"]) : <any>undefined;
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.closedAt = _data["closedAt"] ? new Date(_data["closedAt"].toString()) : <any>undefined;
            this.hasNext = _data["hasNext"];
            this.challengeSet = _data["challengeSet"] ? ChallengeSetDto.fromJS(_data["challengeSet"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new HoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hole"] = this.hole ? this.hole.toJSON() : <any>undefined;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["closedAt"] = this.closedAt ? this.closedAt.toISOString() : <any>undefined;
        data["hasNext"] = this.hasNext;
        data["challengeSet"] = this.challengeSet ? this.challengeSet.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHoleDto {
    hole: Hole | undefined;
    start: Date;
    end: Date;
    closedAt: Date | undefined;
    hasNext: boolean;
    challengeSet: ChallengeSetDto | undefined;
}

export class Hole implements IHole {
    holeId!: string;
    challengeId!: string;
    duration!: string;
    rank!: number;

    constructor(data?: IHole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holeId = _data["holeId"];
            this.challengeId = _data["challengeId"];
            this.duration = _data["duration"];
            this.rank = _data["rank"];
        }
    }

    static fromJS(data: any): Hole {
        data = typeof data === 'object' ? data : {};
        let result = new Hole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holeId"] = this.holeId;
        data["challengeId"] = this.challengeId;
        data["duration"] = this.duration;
        data["rank"] = this.rank;
        return data; 
    }
}

export interface IHole {
    holeId: string;
    challengeId: string;
    duration: string;
    rank: number;
}

export class ChallengeSetDto implements IChallengeSetDto {
    id!: string;
    title!: string | undefined;
    description!: string | undefined;
    returnType!: string | undefined;
    params!: ParamsDescriptionDto[] | undefined;
    challenges!: ChallengeDto[] | undefined;

    constructor(data?: IChallengeSetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.returnType = _data["returnType"];
            if (Array.isArray(_data["params"])) {
                this.params = [] as any;
                for (let item of _data["params"])
                    this.params!.push(ParamsDescriptionDto.fromJS(item));
            }
            if (Array.isArray(_data["challenges"])) {
                this.challenges = [] as any;
                for (let item of _data["challenges"])
                    this.challenges!.push(ChallengeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChallengeSetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChallengeSetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["returnType"] = this.returnType;
        if (Array.isArray(this.params)) {
            data["params"] = [];
            for (let item of this.params)
                data["params"].push(item.toJSON());
        }
        if (Array.isArray(this.challenges)) {
            data["challenges"] = [];
            for (let item of this.challenges)
                data["challenges"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChallengeSetDto {
    id: string;
    title: string | undefined;
    description: string | undefined;
    returnType: string | undefined;
    params: ParamsDescriptionDto[] | undefined;
    challenges: ChallengeDto[] | undefined;
}

export class ParamsDescriptionDto implements IParamsDescriptionDto {
    type!: string | undefined;
    suggestedName!: string | undefined;

    constructor(data?: IParamsDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.suggestedName = _data["suggestedName"];
        }
    }

    static fromJS(data: any): ParamsDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParamsDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["suggestedName"] = this.suggestedName;
        return data; 
    }
}

export interface IParamsDescriptionDto {
    type: string | undefined;
    suggestedName: string | undefined;
}

export class ChallengeDto implements IChallengeDto {
    args!: string[] | undefined;
    expectedResult!: string | undefined;

    constructor(data?: IChallengeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["args"])) {
                this.args = [] as any;
                for (let item of _data["args"])
                    this.args!.push(item);
            }
            this.expectedResult = _data["expectedResult"];
        }
    }

    static fromJS(data: any): ChallengeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChallengeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.args)) {
            data["args"] = [];
            for (let item of this.args)
                data["args"].push(item);
        }
        data["expectedResult"] = this.expectedResult;
        return data; 
    }
}

export interface IChallengeDto {
    args: string[] | undefined;
    expectedResult: string | undefined;
}

export class ResultDto implements IResultDto {
    rank!: number;
    loginName!: string | undefined;
    avatarUri!: string | undefined;
    score!: number;

    constructor(data?: IResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rank = _data["rank"];
            this.loginName = _data["loginName"];
            this.avatarUri = _data["avatarUri"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): ResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rank"] = this.rank;
        data["loginName"] = this.loginName;
        data["avatarUri"] = this.avatarUri;
        data["score"] = this.score;
        return data; 
    }
}

export interface IResultDto {
    rank: number;
    loginName: string | undefined;
    avatarUri: string | undefined;
    score: number;
}

export class AttemptCodeDto implements IAttemptCodeDto {
    id!: string;
    loginName!: string | undefined;
    avatar!: string | undefined;
    score!: number;
    code!: string | undefined;
    timeStamp!: string | undefined;

    constructor(data?: IAttemptCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loginName = _data["loginName"];
            this.avatar = _data["avatar"];
            this.score = _data["score"];
            this.code = _data["code"];
            this.timeStamp = _data["timeStamp"];
        }
    }

    static fromJS(data: any): AttemptCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttemptCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loginName"] = this.loginName;
        data["avatar"] = this.avatar;
        data["score"] = this.score;
        data["code"] = this.code;
        data["timeStamp"] = this.timeStamp;
        return data; 
    }
}

export interface IAttemptCodeDto {
    id: string;
    loginName: string | undefined;
    avatar: string | undefined;
    score: number;
    code: string | undefined;
    timeStamp: string | undefined;
}

export class GameDto implements IGameDto {
    id!: string;
    accessKey!: string | undefined;
    rounds!: RoundDto[] | undefined;

    constructor(data?: IGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accessKey = _data["accessKey"];
            if (Array.isArray(_data["rounds"])) {
                this.rounds = [] as any;
                for (let item of _data["rounds"])
                    this.rounds!.push(RoundDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GameDto {
        data = typeof data === 'object' ? data : {};
        let result = new GameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accessKey"] = this.accessKey;
        if (Array.isArray(this.rounds)) {
            data["rounds"] = [];
            for (let item of this.rounds)
                data["rounds"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGameDto {
    id: string;
    accessKey: string | undefined;
    rounds: RoundDto[] | undefined;
}

export class RoundDto implements IRoundDto {
    id!: string;
    name!: string | undefined;

    constructor(data?: IRoundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoundDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRoundDto {
    id: string;
    name: string | undefined;
}

export class ChallengeOverView implements IChallengeOverView {
    id!: string;
    title!: string | undefined;
    description!: string | undefined;

    constructor(data?: IChallengeOverView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ChallengeOverView {
        data = typeof data === 'object' ? data : {};
        let result = new ChallengeOverView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        return data; 
    }
}

export interface IChallengeOverView {
    id: string;
    title: string | undefined;
    description: string | undefined;
}

export class SubmissionResult implements ISubmissionResult {
    score!: number | undefined;
    runErrors!: ChallengeResult[] | undefined;
    compileErrors!: CompileErrorMessage[] | undefined;

    constructor(data?: ISubmissionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.score = _data["score"];
            if (Array.isArray(_data["runErrors"])) {
                this.runErrors = [] as any;
                for (let item of _data["runErrors"])
                    this.runErrors!.push(ChallengeResult.fromJS(item));
            }
            if (Array.isArray(_data["compileErrors"])) {
                this.compileErrors = [] as any;
                for (let item of _data["compileErrors"])
                    this.compileErrors!.push(CompileErrorMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmissionResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubmissionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["score"] = this.score;
        if (Array.isArray(this.runErrors)) {
            data["runErrors"] = [];
            for (let item of this.runErrors)
                data["runErrors"].push(item.toJSON());
        }
        if (Array.isArray(this.compileErrors)) {
            data["compileErrors"] = [];
            for (let item of this.compileErrors)
                data["compileErrors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISubmissionResult {
    score: number | undefined;
    runErrors: ChallengeResult[] | undefined;
    compileErrors: CompileErrorMessage[] | undefined;
}

export class ChallengeResult implements IChallengeResult {
    error!: ErrorDto | undefined;

    constructor(data?: IChallengeResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChallengeResult {
        data = typeof data === 'object' ? data : {};
        let result = new ChallengeResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IChallengeResult {
    error: ErrorDto | undefined;
}

export class ErrorDto implements IErrorDto {
    message!: string | undefined;
    found!: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.found = _data["found"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["found"] = this.found;
        return data; 
    }
}

export interface IErrorDto {
    message: string | undefined;
    found: string | undefined;
}

export class CompileErrorMessage implements ICompileErrorMessage {
    line!: number;
    col!: number;
    endCol!: number;
    message!: string | undefined;

    constructor(data?: ICompileErrorMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.line = _data["line"];
            this.col = _data["col"];
            this.endCol = _data["endCol"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CompileErrorMessage {
        data = typeof data === 'object' ? data : {};
        let result = new CompileErrorMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line"] = this.line;
        data["col"] = this.col;
        data["endCol"] = this.endCol;
        data["message"] = this.message;
        return data; 
    }
}

export interface ICompileErrorMessage {
    line: number;
    col: number;
    endCol: number;
    message: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}